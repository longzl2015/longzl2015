<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://longzl2015.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"我们没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":true},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="bean的创建和初始化(非 bean 配置的解析和注册)">
<meta property="og:type" content="article">
<meta property="og:title" content="spring-3-bean的创建和初始化(转)">
<meta property="og:url" content="https://longzl2015.github.io/2019/10/16/spring/spring-core/spring-1-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="bean的创建和初始化(非 bean 配置的解析和注册)">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-10-16T16:00:02.000Z">
<meta property="article:modified_time" content="2020-02-27T09:16:07.899Z">
<meta property="article:author" content="zhoul">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="springframe">
<meta property="article:tag" content="bean">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://longzl2015.github.io/2019/10/16/spring/spring-core/spring-1-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>spring-3-bean的创建和初始化(转) | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">190</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">92</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">351</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://longzl2015.github.io/2019/10/16/spring/spring-core/spring-1-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhoul">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          spring-3-bean的创建和初始化(转)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-17 00:00:02" itemprop="dateCreated datePublished" datetime="2019-10-17T00:00:02+08:00">2019-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-02-27 17:16:07" itemprop="dateModified" datetime="2020-02-27T17:16:07+08:00">2020-02-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/" itemprop="url" rel="index">
                    <span itemprop="name">spring</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/spring/spring-core/" itemprop="url" rel="index">
                    <span itemprop="name">spring-core</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2019/10/16/spring/spring-core/spring-1-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/#comments" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/10/16/spring/spring-core/spring-1-bean的创建和初始化/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>bean的创建和初始化(非 bean 配置的解析和注册)</p>
<a id="more"></a>

<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Spring 提供了多种重载和覆盖的 getBean 方法，当我们在执行 beanFactory.getBean(“myBean”) 时，我们实际上是在调用 AbstractBeanFactory 中的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照 Spring 中方法的命名规则，以 “do” 开头的方法一般都是真正干事的地方，doGetBean 方法也不例外，其中包含了整个创建和获取 bean 的过程，在前面的文章中我们已经简单的浏览过该方法，这里我们再看一遍，并针对其中的逻辑进行展开：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 获取name对应的真正beanName</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 因为传入的参数可以是alias，也可能是FactoryBean的name，所以需要进行解析，包含以下内容：</span></span><br><span class="line"><span class="comment">     * 1. 如果是FactoryBean，则去掉修饰符“&amp;”</span></span><br><span class="line"><span class="comment">     * 2. 沿着引用链获取alias对应的最终name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = <span class="keyword">this</span>.transformedBeanName(name);</span><br><span class="line"></span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 检查缓存或者实例工厂中是否有对应的单例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 在创建单例bean的时候会存在依赖注入的情况，而在创建依赖的时候为了避免循环依赖</span></span><br><span class="line"><span class="comment">     * Spring创建bean的原则是不等bean创建完成就会将创建bean的ObjectFactory提前曝光（将对应的ObjectFactory加入到缓存）</span></span><br><span class="line"><span class="comment">     * 一旦下一个bean创建需要依赖上一个bean，则直接使用ObjectFactory对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object sharedInstance = <span class="keyword">this</span>.getSingleton(beanName); <span class="comment">// 获取单例</span></span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 实例已经存在，返回对应的实例</span></span><br><span class="line">        bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单例实例不存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 只有在单例模式下才会尝试解决循环依赖问题</span></span><br><span class="line"><span class="comment">             * 对于原型模式，如果存在循环依赖，也就是满足this.isPrototypeCurrentlyInCreation(beanName)，抛出异常</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取parentBeanFactory实例</span></span><br><span class="line">        BeanFactory parentBeanFactory = <span class="keyword">this</span>.getParentBeanFactory();</span><br><span class="line">        <span class="comment">// 如果在beanDefinitionMap中（即所有已经加载的类中）不包含目标bean，则尝试从parentBeanFactory中获取</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            String nameToLookup = <span class="keyword">this</span>.originalBeanName(name);  <span class="comment">// 获取name对应的真正beanName，如果是factoryBean，则加上“&amp;”前缀</span></span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 递归到BeanFactory中寻找</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不仅仅是做类型检查，标记bean的状态已经创建，即将beanName加入alreadyCreated集合中</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            <span class="keyword">this</span>.markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 将存储XML配置的GenericBeanDefinition实例转换成RootBeanDefinition实例，方便后续处理</span></span><br><span class="line"><span class="comment">             * 如果存在父bean，则同时合并父bean的相关属性</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            <span class="comment">// 检查bean是否是抽象的，如果是则抛出异常</span></span><br><span class="line">            <span class="keyword">this</span>.checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加载当前bean依赖的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 存在依赖，递归实例化依赖的bean</span></span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="comment">// 检查dep是否依赖beanName，从而导致循环依赖</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 缓存依赖调用</span></span><br><span class="line">                    <span class="keyword">this</span>.registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">this</span>.getBean(dep);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成加载依赖的bean后，实例化mbd自身</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">// scope == singleton</span></span><br><span class="line">                sharedInstance = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            <span class="comment">// 清理工作，从单例缓存中移除</span></span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// scope == prototype</span></span><br><span class="line">                Object prototypeInstance;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 设置正在创建的状态</span></span><br><span class="line">                    <span class="keyword">this</span>.beforePrototypeCreation(beanName);</span><br><span class="line">                    <span class="comment">// 创建bean</span></span><br><span class="line">                    prototypeInstance = <span class="keyword">this</span>.createBean(beanName, mbd, args);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回对应的实例</span></span><br><span class="line">                bean = <span class="keyword">this</span>.getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其它scope</span></span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 返回对应的实例</span></span><br><span class="line">                    bean = <span class="keyword">this</span>.getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查需要的类型是否符合bean的实际类型，对应getBean时指定的requireType</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行类型转换，转换成期望的类型</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> + ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个方法的过程可以概括为：</p>
<ol>
<li>获取参数 name 对应的真正的 beanName</li>
<li>检查缓存或者实例工厂中是否有对应的单例，若存在则进行实例化并返回对象，否则继续往下执行</li>
<li>执行 prototype 类型依赖检查，防止循环依赖</li>
<li>如果当前 beanFactory 中不存在需要的 bean，则尝试从 parentBeanFactory 中获取</li>
<li>将之前解析过程返得到的 GenericBeanDefinition 对象合并为 RootBeanDefinition 对象，便于后续处理</li>
<li>如果存在依赖的 bean，则进行递归加载</li>
<li>依据当前 bean 的作用域对 bean 进行实例化</li>
<li>如果对返回 bean 类型有要求，则进行类型检查，并按需做类型转换</li>
<li>返回 bean 实例</li>
</ol>
<p>接下来我们针对各步骤中的详细过程按照需要进行逐一探究。</p>
<h2 id="获取真正的-beanName"><a href="#获取真正的-beanName" class="headerlink" title="获取真正的 beanName"></a>获取真正的 beanName</h2><p>我们在调用 getBean 方法的时候传递的 name 可以是 bean 的别名，也可以是获取 factoryBean 实例的 name，所以当我们以 name 为 key 检索 bean 的时候，首先需要获取 name 对应的唯一标识 bean 的真正名称 beanName，这一过程位于 transformedBeanName(String name) 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">transformedBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.canonicalName(BeanFactoryUtils.transformedBeanName(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法首先会通过 BeanFactoryUtils 工具类方法判断是不是获取 factoryBean，如果是的话就去掉 name 前面的 “&amp;” 字符，然后执行 canonicalName(String name) 逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">canonicalName</span><span class="params">(String name)</span> </span>&#123;  <span class="comment">// canonical：权威的</span></span><br><span class="line">    String canonicalName = name;</span><br><span class="line">    String resolvedName;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        resolvedName = <span class="keyword">this</span>.aliasMap.get(canonicalName);</span><br><span class="line">        <span class="keyword">if</span> (resolvedName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            canonicalName = resolvedName;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历寻找真正的name，因为可能存在引用链</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (resolvedName != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> canonicalName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这里当 <code>resolvedName != null</code> 的时候需要继续循环呢，这是因为一个别名所引用的不一定是一个最终的 beanName，可以是另外一个别名，这个时候就是一个链式引用的场景，我们需要继续沿着引用链往下寻找最终的 beanName。</p>
<h2 id="尝试从单例集合中获取目标-bean"><a href="#尝试从单例集合中获取目标-bean" class="headerlink" title="尝试从单例集合中获取目标 bean"></a>尝试从单例集合中获取目标 bean</h2><p>容器首先尝试从单例对象集合中获取 bean 实例，我们都知道单例对象在容器中只会存在一份，所以首先检查单例集合也符合常理，获取单例对象的方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// true表示允许早期依赖</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法第二个参数设置为 true，即 <code>allowEarlyReference=true</code>，表示允许对 bean 的早期依赖，Spring 中 bean 的依赖关系由开发者控制，具备极大的自由配置空间，如果配置不当，可能会导致循环依赖的场景，即 A 依赖于 B，而 B 又依赖于 A，当初始化 A 的时候，检测到引用的 B 还没有实例化，就会转去实例 B，实例化 B 的过程中又会发现 A 还没有实例化完成，从而又回来实例化 A，因此陷入死锁。而 allowEarlyReference 则会提前曝光 bean 的创建过程，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 singletonObjects 缓存中是否存在 单例实例</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName); <span class="comment">// singletonObjects: key(beanName) value(bean实例)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> <span class="comment">// singletonObjects缓存中为空</span></span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;  <span class="comment">// bean正在创建中</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName); <span class="comment">// earlySingletonObjects:key(beanName) value(bean实例)（这里的实例还处于创建中）</span></span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">// 当某些方法需要提前初始化的时候，</span></span><br><span class="line">                <span class="comment">// 会调用addSingletonFactory将对应的objectFactory存储在singletonFactories中</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName); <span class="comment">// singletonFactories key(beanName) value(ObjectFactory)</span></span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">// earlySingletonObjects 和 singletonFactories互斥</span></span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的逻辑是<br>首先从存放 bean 实例的集合 singletonObjects 中获取实例，<br>如果实例不存在且正在创建中，则尝试从 earlySingletonObjects 中获取正在创建中的 bean 实例，<br>如果仍然不存在并且允许早期依赖，则将 ObjectFactory 提前曝光。</p>
<blockquote>
<p><strong>singletonObjects 和 earlySingletonObjects 的区别</strong></p>
<p>两者都是以 beanName 为 key，bean 实例为 value 进行存储，区别在于<br>singletonObjects 存储的是实例化完成的 bean 实例，<br>earlySingletonObjects 存储的是正在实例化中的 bean，<br>所以两个集合的内容也是互斥的。</p>
</blockquote>
<h2 id="从-bean-实例中获取目标对象"><a href="#从-bean-实例中获取目标对象" class="headerlink" title="从 bean 实例中获取目标对象"></a>从 bean 实例中获取目标对象</h2><p>如果上一步我们获取到了单例 bean 实例，那么我们需要接着调用 getObjectForBeanInstance 方法，该方法在 doGetBean 的过程中被多次调用，每次我们获取到 bean 实例之后，不管是从单例集合中获取、还是实时生成各个作用域对象，我们都需要调用一次该方法，该方法的主要目的是判断当前 bean 实例是否是 FactoryBean，如果是 FactoryBean 实例，同时用户希望获取的是真正的 bean 实例（即 name 不是以 “&amp;” 开头），此时就需要由 FactoryBean 实例创建目标 bean 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="comment">// 获取FactoryBean，但是对应的bean并不是FactoryBean类型</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一个bean实例，可以是普通的bean，也可能是FactoryBean</span></span><br><span class="line"><span class="comment">     * 该bean实例不是FactoryBean or 本来就是希望获取FactoryBean实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) <span class="comment">// 不是FactoryBean，直接返回</span></span><br><span class="line">            || BeanFactoryUtils.isFactoryDereference(name)) &#123; <span class="comment">// 希望仅仅获取FactoryBean实例，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取由FactoryBean创建的bean实例</span></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 尝试从factoryBeanObjectCache缓存中获取bean实例</span></span><br><span class="line">        object = <span class="keyword">this</span>.getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理FactoryBean</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsBeanDefinition(beanName)) &#123;  <span class="comment">// beanName已经注册</span></span><br><span class="line">            <span class="comment">// 指定merge操作</span></span><br><span class="line">            mbd = <span class="keyword">this</span>.getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否是用户定义的，而不是应用程序自己定义的</span></span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        <span class="comment">// 核心代码：getObjectFromFactoryBean</span></span><br><span class="line">        object = <span class="keyword">this</span>.getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法首先会进行一些基础校验，如果用户希望获取的是 FactoryBean 实例，但是当前的实例明确不是 FactoryBean 实例则抛出异常，否则除非当前实例是 FactoryBean 实例，同时用户又希望获取由 FactoryBean 实例创建的对象，其余情况直接返回 bean 实例。</p>
<p>接下来就是处理由 FactoryBean 实例创建目标 bean 对象的过程，首先容器会尝试从缓存中获取，因为对于一些单例的 bean 来说，可能之前已经完成了创建，如果缓存不命中则执行创建过程，这里继续调用 getObjectFromFactoryBean 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectFromFactoryBean</span><span class="params">(FactoryBean&lt;?&gt; factory, String beanName, <span class="keyword">boolean</span> shouldPostProcess)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (factory.isSingleton() &amp;&amp; <span class="keyword">this</span>.containsSingleton(beanName)) &#123;</span><br><span class="line">        <span class="comment">// 如果是单例，且factoryBean已经实例化</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.getSingletonMutex()) &#123;</span><br><span class="line">            <span class="comment">// 尝试从缓存中获取， factoryBeanObjectCache以factoryBeanName为key存储由FactoryBean创建的实例</span></span><br><span class="line">            Object object = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用FactoryBean的getObject方法创建对象</span></span><br><span class="line">                object = <span class="keyword">this</span>.doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">                <span class="comment">// 尝试获取已经缓存的实例</span></span><br><span class="line">                Object alreadyThere = <span class="keyword">this</span>.factoryBeanObjectCache.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (alreadyThere != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    object = alreadyThere;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 调用后置处理器</span></span><br><span class="line">                            object = <span class="keyword">this</span>.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's singleton object failed"</span>, ex);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 缓存，以 factoryBeanName 为key，由FactoryBean创建的对象为value</span></span><br><span class="line">                    <span class="keyword">this</span>.factoryBeanObjectCache.put(beanName, (object != <span class="keyword">null</span> ? object : NULL_OBJECT));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (object != NULL_OBJECT ? object : <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用FactoryBean的getObject方法创建对象</span></span><br><span class="line">        Object object = <span class="keyword">this</span>.doGetObjectFromFactoryBean(factory, beanName);</span><br><span class="line">        <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; shouldPostProcess) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用后置处理器</span></span><br><span class="line">                object = <span class="keyword">this</span>.postProcessObjectFromFactoryBean(object, beanName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"Post-processing of FactoryBean's object failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法对于单例来说，保证单例在容器中的唯一性，同时触发后置处理器，而我们期望的创建 bean 实例的逻辑位于 doGetObjectFromFactoryBean 方法中，这里才是调用我们在使用 FactoryBean 构造对象所覆盖的 getObject 方法的地方，前面的文章已经介绍过 FactoryBean，并演示了 FactoryBean 的使用方法，再来回顾一下 FactoryBean 的构成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">/** 获取由 FactoryBean 创建的目标 bean 实例*/</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">	<span class="comment">/** 返回目标 bean 类型 */</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line">	<span class="comment">/** 是否是单实例 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FactoryBean 接口仅仅包含 3 个方法，而 getObject 是用来真正创建对象的地方，当我们在调用 BeanFactory 的 getBean 方法不加 “&amp;” 获取 bean 实例时，这个时候 getBean 可以看做是 getObject 方法的代理方法，而具体调用就在 doGetObjectFromFactoryBean 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 需要权限验证</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessControlContext acc = <span class="keyword">this</span>.getAccessControlContext();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                object = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> factory.getObject();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 直接调用getObject方法，FactoryBean的getObject方法代理了getBean</span></span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FactoryBeanNotInitializedException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, ex.toString());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName, <span class="string">"FactoryBean threw exception on object creation"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// FactoryBean未成功创建对象，或factoryBean实例正在被创建</span></span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName, <span class="string">"FactoryBean which is currently in creation returned null from getObject"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法中的 factory.getObject() 是我们一层层剥离外表所触及到的核心，其具体实现则交给了开发者。</p>
<h2 id="创建-bean-实例"><a href="#创建-bean-实例" class="headerlink" title="创建 bean 实例"></a>创建 bean 实例</h2><p>如果单例缓存集合中不存在目标 bean 实例，那么说明当前 bean 可能是一个非单例对象，或者是一个单例但却是第一次加载，如果前面的操作是获取对象，那么这里就需要真正创建对象了，在具体创建对象之前，需要做如下几步操作：</p>
<blockquote>
<ol>
<li>对 prototype 对象的循环依赖进行检查，如果存在循环依赖则直接抛出异常，而不尝试去解决循环依赖。</li>
<li>检测目标 bean 是否属于当前 BeanFactory 的管辖范围，如果不属于，同时又存在父 BeanFactory，则委托给父 BeanFactory 进行处理。</li>
<li>检测是不是仅仅做类型检查，如果不是则清空 merge 标记，并标记当前 bean 为已创建状态</li>
<li>将存储XML配置的GenericBeanDefinition实例转换成RootBeanDefinition实例，方便后续处理</li>
<li>检查依赖的 bean，如果存在且未实例化，则先递归实例化依赖的 bean</li>
</ol>
</blockquote>
<p>完成了上述流程之后，容器针对具体的作用域采取适当的方法创建对应的 bean 实例。</p>
<h3 id="创建单例对象"><a href="#创建单例对象" class="headerlink" title="创建单例对象"></a>创建单例对象</h3><p>之前尝试从单例缓存集合中获取单例对象，而能够走到这里说明之前缓存不命中，对应的单例对象还没有创建，需要现在开始实时创建，这个过程位于 getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) 方法中，这是一个重载方法，与前面从缓存中获取单例对象的方法在参数上存在差别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(beanName, <span class="string">"'beanName' must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;  <span class="comment">// singletonObjects用于缓存beanName与已创建的单例对象的映射关系</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123; <span class="comment">// 对应的bean没有加载过</span></span><br><span class="line">            <span class="comment">// 开始singleton bean的初始化过程</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">                <span class="comment">// 对应的bean正在其它地方创建中</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">                        <span class="string">"Singleton bean creation not allowed while singletons of this factory are in destruction (Do not request a bean from a BeanFactory in a destroy method implementation!)"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 前置处理，对于需要依赖检测的bean，设置状态为“正在创建中”</span></span><br><span class="line">            <span class="keyword">this</span>.beforeSingletonCreation(beanName);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;Exception&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 实例化bean</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// 异常，再次尝试从缓存中获取</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> ex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Exception suppressedException : <span class="keyword">this</span>.suppressedExceptions) &#123;</span><br><span class="line">                        ex.addRelatedCause(suppressedException);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 后置处理，对于需要依赖检测的bean，移除“正在创建中”的状态</span></span><br><span class="line">                <span class="keyword">this</span>.afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123; <span class="comment">// 新实例</span></span><br><span class="line">                <span class="comment">// 加入缓存</span></span><br><span class="line">                <span class="keyword">this</span>.addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回实例</span></span><br><span class="line">        <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个方法的逻辑还是很直观的，流程概括如下：</p>
<blockquote>
<ol>
<li>检测 bean 是否正在其它地方被创建，是的话抛异常并中断流程</li>
<li>标记 bean 的状态为“正在创建中”</li>
<li>实例化 bean，如果过程中出现异常，则尝试从缓存中获取实例</li>
<li>移除 bean 的“正在创建中”的状态</li>
<li>将 bean 实例加入缓存，并返回实例</li>
</ol>
</blockquote>
<p>步骤三中的实例化 bean 是整个流程的关键所在，这里调用了参数 singletonFactory 的 getObject 方法，由前面传入的参数我们可以知道 getObject 中的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// 清理工作，从单例缓存中移除</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>所以创建 bean 的真正逻辑位于 createBean 方法中，该方法的具体实现位于 AbstractAutowireCapableBeanFactory 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.根据设置的class属性或className来解析得到Class引用</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.对override属性进行标记和验证，本质上是处理lookup-method和replaced-method标签</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 处理 InstantiationAwareBeanPostProcessor</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object bean = <span class="keyword">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果处理结果不为null，则直接返回，而不执行后续的createBean</span></span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName, <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建bean实例</span></span><br><span class="line">    Object beanInstance = <span class="keyword">this</span>.doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法虽然叫 createBean，但仍然不是真正创建 bean 实例的地方，该方法主要还是在做一些前期准备工作，具体的流程参见代码注释，下面针对各个过程来逐一探究。</p>
<h4 id="获取-class-引用"><a href="#获取-class-引用" class="headerlink" title="获取 class 引用"></a>获取 class 引用</h4><p>不知道你是否还记得，在对标签解析过程的探究中，对于 class 属性的解析，如果参数中传入了类加载器则会尝试获取其 class 引用，否则直接记录类的全称类名，对于前者这里的解析就是直接返回引用，而后者则需要在此对其进行解析得到对应的 class 引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveBeanClass(<span class="keyword">final</span> RootBeanDefinition mbd, String beanName, <span class="keyword">final</span> Class&lt;?&gt;... typesToMatch)</span><br><span class="line">        <span class="keyword">throws</span> CannotLoadBeanClassException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mbd.hasBeanClass()) &#123;</span><br><span class="line">            <span class="comment">// 如果之前直接存储的class引用则直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mbd.getBeanClass();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则由beanClassName解析得到class引用</span></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// 解析得到bean引用</span></span><br><span class="line">                    <span class="keyword">return</span> doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解析得到bean引用</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.doResolveBeanClass(mbd, typesToMatch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">        ClassNotFoundException ex = (ClassNotFoundException) pae.getException();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (LinkageError ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CannotLoadBeanClassException(mbd.getResourceDescription(), beanName, mbd.getBeanClassName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很清晰，如果 beanDefinition 实例中记录已经是 class 引用则直接返回，否则进行解析，即 doResolveBeanClass 方法，该方法会验证类全称类名，并利用类加载器解析获取 class 引用，具体不再展开。</p>
<h4 id="处理-override-属性"><a href="#处理-override-属性" class="headerlink" title="处理 override 属性"></a>处理 override 属性</h4><p>Spring 中并不存在 <code>override-method</code> 的标签，这里的 override 指的是 <lookup-method/> 和 <replaced-method/> 两个标签，之前解析这两个标签时是将这两个标签配置以 MethodOverride 对象的形式记录在 beanDefinition 实例的 methodOverrides 属性中，而这里的处理主要是逐一检查所覆盖的方法是否存在，如果不存在则覆盖无效，如果存在唯一的方法，则覆盖是明确的，标记后期无需依据参数类型以及个数进行推测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取之前记录的&lt;lookup-method/&gt;和&lt;replaced-method/&gt;标签配置</span></span><br><span class="line">    MethodOverrides methodOverrides = <span class="keyword">this</span>.getMethodOverrides();</span><br><span class="line">    <span class="keyword">if</span> (!methodOverrides.isEmpty()) &#123;</span><br><span class="line">        Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();</span><br><span class="line">        <span class="keyword">synchronized</span> (overrides) &#123;</span><br><span class="line">            <span class="keyword">for</span> (MethodOverride mo : overrides) &#123;</span><br><span class="line">                <span class="comment">// 逐一处理</span></span><br><span class="line">                <span class="keyword">this</span>.prepareMethodOverride(mo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareMethodOverride</span><span class="params">(MethodOverride mo)</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">    <span class="comment">// 获取指定类中指定方法名的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = ClassUtils.getMethodCountForName(<span class="keyword">this</span>.getBeanClass(), mo.getMethodName());</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 无效</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionValidationException(<span class="string">"Invalid method override: no method with name '"</span> + mo.getMethodName() + <span class="string">"' on class ["</span> + getBeanClassName() + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 标记MethodOverride暂未被覆盖，避免参数类型检查的开销</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 如果一个方法存在多个重载，那么在调用及增强的时候还需要根据参数类型进行匹配来最终确认调用的函数</span></span><br><span class="line"><span class="comment">         * 如果方法只有一个，就在这里设置重载为false，后续可以直接定位方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        mo.setOverloaded(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理-InstantiationAwareBeanPostProcessor"><a href="#处理-InstantiationAwareBeanPostProcessor" class="headerlink" title="处理 InstantiationAwareBeanPostProcessor"></a>处理 InstantiationAwareBeanPostProcessor</h4><p>接下来主要处理 InstantiationAwareBeanPostProcessor 处理器，我们先来回忆一下该处理器的作用。该处理器的接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InstantiationAwareBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** bean实例化前调用，是对bean定义进行修改的最后机会 */</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** bean实例化后立即调用，位于属性注入之前 */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 在将属性注入bean实例前的属性处理 */</span></span><br><span class="line">    <span class="function">PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上述说明还是能够清晰的知道这个处理器的功能，接口中定义的方法紧挨着 bean 实例化的过程，如果我们希望在实例化前后对 bean 的定义实施一些修改，可以实现该接口并注册到 BeanFactory 中，不过需要注意一点的是处理器会对所有的 bean 生效，而筛选的逻辑需要我们自己实现。</p>
<p>回过头来我们继续探究这里的处理逻辑，如下首先会去解析 bean 的真正 class 引用，因为可能存在一些工厂 bean，而具体的 bean 类型还需要通过工厂方法去推测：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object bean = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123; <span class="comment">// 表示尚未被解析</span></span><br><span class="line">        <span class="comment">// mbd是程序创建的且存在后置处理器</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="comment">// 获取最终的class引用，如果是工厂方法则获取工厂所创建的实例类型</span></span><br><span class="line">            Class&lt;?&gt; targetType = <span class="keyword">this</span>.determineTargetType(beanName, mbd);</span><br><span class="line">            <span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用实例化前置处理器</span></span><br><span class="line">                bean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">                <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 调用实例化后置处理器</span></span><br><span class="line">                    bean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是我们之前说到的 InstantiationAwareBeanPostProcessor 中的应用实例化前置和后置处理器，代码逻辑分别如下：</p>
<ul>
<li><strong>应用实例化前置处理</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">applyBeanPostProcessorsBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化前置处理器</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// 逐一调用处理器</span></span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);</span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>应用实例化后置处理</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化后置处理器</span></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="comment">// 依次采用后置处理器处理</span></span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : <span class="keyword">this</span>.getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然这里的后置处理不是必然调用，而是建立在前置处理实例化了 bean 的前提下，因为真正常规实例化 bean 的过程将在接下来一步进行发生，不过如果这一步已经完成了 bean 的实例化过程，那么也就没有继续执行下去的必要，直接返回即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果处理结果不为null，则直接返回，而不执行后续的createBean</span></span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实例化-bean"><a href="#实例化-bean" class="headerlink" title="实例化 bean"></a>实例化 bean</h4><p>终于挖到了实例化 bean 的地方，实例化 bean 的逻辑还是挺复杂的，我们先来看一下主体流程，如源码中的注释，我们可以将整个过程概括为 7 个步骤：</p>
<blockquote>
<ol>
<li>如果是单例，尝试从缓存中获取 bean 的包装器 BeanWrapper</li>
<li>如果不存在对应的 Wrapper，则说明 bean 未被实例化，创建 bean 实例</li>
<li>应用 MergedBeanDefinitionPostProcessor</li>
<li>检查是否需要提前曝光，避免循环依赖</li>
<li>初始化 bean 实例</li>
<li>再次基于依存关系验证是否存在循环依赖</li>
<li>注册 DisposableBean</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 1. 如果是单例，尝试获取对应的BeanWrapper</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. bean未实例化，创建 bean 实例</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 说明对应的bean还没有创建，用对应的策略（工厂方法、构造函数）创建bean实例，以及简单初始化</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 将beanDefinition转成BeanWrapper，大致流程如下：</span></span><br><span class="line"><span class="comment">         * 1. 如果存在工厂方法，则使用工厂方法初始化</span></span><br><span class="line"><span class="comment">         * 2. 否则，如果存在多个构造函数，则根据参数确定构造函数，并利用构造函数初始化</span></span><br><span class="line"><span class="comment">         * 3. 否则，使用默认构造函数初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从BeanWrapper中获取包装的bean实例</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 从BeanWrapper获取包装bean的class引用</span></span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 应用 MergedBeanDefinitionPostProcessor</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理 merged bean，Autowired通过此方法实现诸如类型的解析</span></span><br><span class="line">                <span class="keyword">this</span>.applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 检查是否需要提前曝光，避免循环依赖，条件：单例 &amp;&amp; 允许循环依赖 &amp;&amp; 当前bean正在创建中</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 为避免循环依赖，在完成bean实例化之前，将对应的ObjectFactory加入bean的工厂</span></span><br><span class="line">        <span class="keyword">this</span>.addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="comment">// 对bean再一次依赖引用，应用SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 初始化bean实例</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 对bean进行填充，将各个属性值注入，如果存在依赖的bean则进行递归初始化</span></span><br><span class="line">        <span class="keyword">this</span>.populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化bean，调用初始化方法，比如init-method</span></span><br><span class="line">            exposedObject = <span class="keyword">this</span>.initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 再次基于依存关系验证是否存在循环依赖</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123; <span class="comment">// 提前曝光</span></span><br><span class="line">        Object earlySingletonReference = <span class="keyword">this</span>.getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123; <span class="comment">// 只有在检测到循环引用的情况下才会不为null</span></span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;  <span class="comment">// exposedObject没有在初始化中被增强</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; <span class="keyword">this</span>.hasDependentBean(beanName)) &#123;</span><br><span class="line">                <span class="comment">// 获取依赖的bean的name</span></span><br><span class="line">                String[] dependentBeans = <span class="keyword">this</span>.getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="comment">// 检测依赖，记录未完成创建的bean</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="keyword">this</span>.removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 因为bean在创建完成之后，其依赖的bean一定是被创建了的</span></span><br><span class="line"><span class="comment">                 * 如果actualDependentBeans不为空，则说明bean依赖的bean没有完成创建，存在循环依赖</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                                    StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                                    <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                                    <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                                    <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                                    <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 7. 注册DisposableBean</span></span><br><span class="line">        <span class="keyword">this</span>.registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对上述过程，我们逐一进行探究。</p>
<p><strong>1. 对于单例，尝试从缓存中获取 BeanWrapper 对象</strong></p>
<p>单例对象是全局唯一的，一旦创建就常驻内存，如果对应的 bean 已经被实例化过，那么这里获取到的是 BeanWrapper 对象，BeanWrapper 可以看作是偏底层的 bean 包装器，提供了对标准 java bean 的分析和操作方法，包括获取和设置属性值、获取属性描述符，以及属性的读写特性等。</p>
<p><strong>2. bean 的实例化过程</strong></p>
<p>如果步骤 1 中没有获取到目标 bean 实例，则说明对应的 bean 还没有被实例化或是非单例的 bean，这个时候就需要创建对象（通过工厂方法或构造函数创建），Spring 创建对象的基本执行流程为：</p>
<blockquote>
<ol>
<li>如果存在工厂方法，则使用工厂方法初始化</li>
<li>否则，如果存在多个构造函数，则根据参数确定构造函数，并利用构造函数初始化</li>
<li>否则，使用默认构造函数初始化</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; beanClass = <span class="keyword">this</span>.resolveBeanClass(mbd, beanName); <span class="comment">// 解析class引用</span></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*1. 如果工厂方法不为空，则使用工厂方法进行实例化*/</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*2. 利用构造函数进行实例化，解析并确定目标构造函数*/</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="comment">// 一个类可能有多个构造函数，需要根据参数来确定具体的构造函数</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果已经解析过，则使用已经确定的构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="comment">// 依据构造函数注入</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 使用默认构造函数构造</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要根据参数决定使用哪个构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = <span class="keyword">this</span>.determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || <span class="comment">// 构造函数注入</span></span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; <span class="comment">// 存在构造函数配置</span></span><br><span class="line">        <span class="comment">// 构造函数自动注入</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*3. 使用默认的构造函数*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述源码是属于框架式的源码，描述了整个实例化的执行流程（如前面所述），接下来我们需要继续往下深入，探究各种实例化过程，以及容器确定目标构造函数的算法。</p>
<p>如果存在 factory-method 则说明存在工厂方法执行实例化，Spring 通过 instantiateUsingFactoryMethod 方法执行实例化过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">instantiateUsingFactoryMethod</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化 BeanWrapper</span></span><br><span class="line">    BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Object factoryBean; <span class="comment">// 工厂</span></span><br><span class="line">    Class&lt;?&gt; factoryClass; <span class="comment">// 工厂所指代的类</span></span><br><span class="line">    <span class="keyword">boolean</span> isStatic;  <span class="comment">// 是不是静态工厂</span></span><br><span class="line">    String factoryBeanName = mbd.getFactoryBeanName(); <span class="comment">// 获取factory-bean</span></span><br><span class="line">    <span class="keyword">if</span> (factoryBeanName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 存在factory-bean，说明是非静态工厂</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;bean id="my-bean-simple-factory" class="org.zhenchao.factory.MyBeanSimpleFactory"/&gt;</span></span><br><span class="line"><span class="comment">         * &lt;bean id="my-bean-1" factory-bean="my-bean-simple-factory" factory-method="create"/&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (factoryBeanName.equals(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, <span class="string">"factory-bean reference points back to the same bean definition"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取工厂bean实例</span></span><br><span class="line">        factoryBean = <span class="keyword">this</span>.beanFactory.getBean(factoryBeanName);</span><br><span class="line">        <span class="keyword">if</span> (factoryBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"factory-bean '"</span> + factoryBeanName + <span class="string">"' (or a BeanPostProcessor involved) returned null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单例不需要由工厂主动创建</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"About-to-be-created singleton instance implicitly appeared through the creation of the factory bean that its bean definition points to"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        factoryClass = factoryBean.getClass();</span><br><span class="line">        isStatic = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 不存在factory-bean，说明是静态工厂</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;bean id="my-bean-2" class="org.zhenchao.factory.MyBeanStaticFactory" factory-method="create"/&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!mbd.hasBeanClass()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbd.getResourceDescription(), beanName, <span class="string">"bean definition declares neither a bean class nor a factory-bean reference"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        factoryBean = <span class="keyword">null</span>;</span><br><span class="line">        factoryClass = mbd.getBeanClass();</span><br><span class="line">        isStatic = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method factoryMethodToUse = <span class="keyword">null</span>;</span><br><span class="line">    ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">    Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// getBean时传递的构造参数</span></span><br><span class="line">        argsToUse = explicitArgs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有则需要进行解析</span></span><br><span class="line">        Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 尝试从缓存中获取</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            factoryMethodToUse = (Method) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                <span class="comment">// 存在已经解析过的工厂方法</span></span><br><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 获取待解析的构造参数</span></span><br><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存命中</span></span><br><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析参数值，必要的话会进行类型转换</span></span><br><span class="line">            argsToUse = <span class="keyword">this</span>.resolvePreparedArguments(beanName, mbd, bw, factoryMethodToUse, argsToResolve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存未命中，则基于参数来解析决策确定的工厂方法</span></span><br><span class="line">    <span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span> || argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取候选的工厂方法</span></span><br><span class="line">        factoryClass = ClassUtils.getUserClass(factoryClass);</span><br><span class="line">        Method[] rawCandidates = <span class="keyword">this</span>.getCandidateMethods(factoryClass, mbd);</span><br><span class="line">        List&lt;Method&gt; candidateSet = <span class="keyword">new</span> ArrayList&lt;Method&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method candidate : rawCandidates) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Modifier.isStatic(candidate.getModifiers()) == isStatic &amp;&amp; mbd.isFactoryMethod(candidate)) &#123;</span><br><span class="line">                candidateSet.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Method[] candidates = candidateSet.toArray(<span class="keyword">new</span> Method[candidateSet.size()]);</span><br><span class="line">        <span class="comment">// 对候选方法进行排序，public在前，参数多的在前</span></span><br><span class="line">        AutowireUtils.sortFactoryMethods(candidates);</span><br><span class="line"></span><br><span class="line">        ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> autowiring = (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Method&gt; ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minNrOfArgs;</span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// getBean时明确指定了参数</span></span><br><span class="line">            minNrOfArgs = explicitArgs.length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有指定，则从beanDefinition实例中解析</span></span><br><span class="line">            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues();</span><br><span class="line">            <span class="comment">// 获取解析到的参数个数</span></span><br><span class="line">            minNrOfArgs = <span class="keyword">this</span>.resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 遍历候选方法</span></span><br><span class="line">        <span class="keyword">for</span> (Method candidate : candidates) &#123;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (paramTypes.length &gt;= minNrOfArgs) &#123;</span><br><span class="line">                ArgumentsHolder argsHolder;</span><br><span class="line">                <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Resolved constructor arguments: type conversion and/or autowiring necessary.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        String[] paramNames = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 获取参数名称探测去</span></span><br><span class="line">                        ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 获取候选方法的参数名称列表</span></span><br><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 依据参数名称和类型创建参数持有对象</span></span><br><span class="line">                        argsHolder = <span class="keyword">this</span>.createArgumentArray(</span><br><span class="line">                                beanName, mbd, resolvedValues, bw, paramTypes, paramNames, candidate, autowiring);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.logger.isTraceEnabled()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.beanFactory.logger.trace(<span class="string">"Ignoring factory method ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 异常，尝试下一个候选工厂方法</span></span><br><span class="line">                        <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            causes = <span class="keyword">new</span> LinkedList&lt;UnsatisfiedDependencyException&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        causes.add(ex);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">                        <span class="comment">// 参数个数不等于期望的参数个数</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 检测是否有不确定的候选方法存在（比如不同方法的参数存在继承关系）</span></span><br><span class="line">                <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                        argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">                <span class="comment">// 选择最近似的候选方法</span></span><br><span class="line">                <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                    factoryMethodToUse = candidate;</span><br><span class="line">                    argsHolderToUse = argsHolder;</span><br><span class="line">                    argsToUse = argsHolder.arguments;</span><br><span class="line">                    minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">                    ambiguousFactoryMethods = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (factoryMethodToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight &amp;&amp;</span><br><span class="line">                        !mbd.isLenientConstructorResolution() &amp;&amp;</span><br><span class="line">                        paramTypes.length == factoryMethodToUse.getParameterTypes().length &amp;&amp;</span><br><span class="line">                        !Arrays.equals(paramTypes, factoryMethodToUse.getParameterTypes())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ambiguousFactoryMethods == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ambiguousFactoryMethods = <span class="keyword">new</span> LinkedHashSet&lt;Method&gt;();</span><br><span class="line">                        ambiguousFactoryMethods.add(factoryMethodToUse);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ambiguousFactoryMethods.add(candidate);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (factoryMethodToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 无法确定具体的工厂方法</span></span><br><span class="line">            <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; argTypes = <span class="keyword">new</span> ArrayList&lt;String&gt;(minNrOfArgs);</span><br><span class="line">            <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object arg : explicitArgs) &#123;</span><br><span class="line">                    argTypes.add(arg != <span class="keyword">null</span> ? arg.getClass().getSimpleName() : <span class="string">"null"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Set&lt;ValueHolder&gt; valueHolders = <span class="keyword">new</span> LinkedHashSet&lt;ValueHolder&gt;(resolvedValues.getArgumentCount());</span><br><span class="line">                valueHolders.addAll(resolvedValues.getIndexedArgumentValues().values());</span><br><span class="line">                valueHolders.addAll(resolvedValues.getGenericArgumentValues());</span><br><span class="line">                <span class="keyword">for</span> (ValueHolder value : valueHolders) &#123;</span><br><span class="line">                    String argType = (value.getType() != <span class="keyword">null</span> ? ClassUtils.getShortName(value.getType()) :</span><br><span class="line">                            (value.getValue() != <span class="keyword">null</span> ? value.getValue().getClass().getSimpleName() : <span class="string">"null"</span>));</span><br><span class="line">                    argTypes.add(argType);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String argDesc = StringUtils.collectionToCommaDelimitedString(argTypes);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"No matching factory method found: "</span> +  (mbd.getFactoryBeanName() != <span class="keyword">null</span> ?  <span class="string">"factory bean '"</span> + mbd.getFactoryBeanName() + <span class="string">"'; "</span> : <span class="string">""</span>) +</span><br><span class="line">                            <span class="string">"factory method '"</span> + mbd.getFactoryMethodName() + <span class="string">"("</span> + argDesc + <span class="string">")'. "</span> + <span class="string">"Check that a method with the specified name "</span> +</span><br><span class="line">                            (minNrOfArgs &gt; <span class="number">0</span> ? <span class="string">"and arguments "</span> : <span class="string">""</span>) + <span class="string">"exists and that it is "</span> +  (isStatic ? <span class="string">"static"</span> : <span class="string">"non-static"</span>) + <span class="string">"."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">void</span><span class="class">.<span class="keyword">class</span> </span>== factoryMethodToUse.getReturnType()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Invalid factory method '"</span> + mbd.getFactoryMethodName() + <span class="string">"': needs to have a non-void return type!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousFactoryMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Ambiguous factory method matches found in bean '"</span> + beanName + <span class="string">"' "</span> + <span class="string">"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> +  ambiguousFactoryMethods);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span> &amp;&amp; argsHolderToUse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓存</span></span><br><span class="line">            argsHolderToUse.storeCache(mbd, factoryMethodToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用工厂方法创建bean实例</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Object fb = factoryBean;</span><br><span class="line">            <span class="keyword">final</span> Method factoryMethod = factoryMethodToUse;</span><br><span class="line">            <span class="keyword">final</span> Object[] args = argsToUse;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                            mbd, beanName, beanFactory, fb, factoryMethod, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, beanFactory.getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 基于java反射调用工厂bean的指定方法依据给定的参数进行实例化</span></span><br><span class="line">            beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                    mbd, beanName, <span class="keyword">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (beanInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bw.setBeanInstance(beanInstance);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Bean instantiation via factory method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法实现真的很长！不过整个方法主要做了三件事情：</p>
<blockquote>
<ol>
<li>确定当前使用的是静态工厂配置还是一般工厂配置。</li>
<li>确定用于实例化 bean 的工厂方法。</li>
<li>调用工厂方法实例化 bean。</li>
</ol>
</blockquote>
<p>其中最复杂的是步骤 2，因为可能存在多个工厂方法的重载版本，所以需要依据给定或配置的参数个数和类型去解析确定的工厂方法，Spring 会对所有的候选工厂方法按照 public 优先，以及参数个数多的方法优先的原则，对候选方法进行排序，然后逐个比对是否满足当前指定的参数列表，依次确定具体使用哪个工厂方法来进行实例化，这个过程与我们后面介绍的通过构造方法进行实例化时确定具体构造方法的过程大同小异，后面你还会看到与此相似的解析过程。</p>
<p>跳出这个方法，我们继续之前的逻辑往下走，如果一个 bean 没有配置工厂方法则需要通过构造函数进行实例化，如前面所说，一个类也可能存在多个重载的构造方法，所以需要依据给定或配置的构造参数进行决策：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, RootBeanDefinition mbd, Constructor&lt;?&gt;[] ctors, Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConstructorResolver(<span class="keyword">this</span>).autowireConstructor(beanName, mbd, ctors, explicitArgs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanWrapper <span class="title">autowireConstructor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, Constructor&lt;?&gt;[] chosenCtors, <span class="keyword">final</span> Object[] explicitArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建并初始化BeanWrapper</span></span><br><span class="line">    BeanWrapperImpl bw = <span class="keyword">new</span> BeanWrapperImpl();</span><br><span class="line">    <span class="keyword">this</span>.beanFactory.initBeanWrapper(bw);</span><br><span class="line"></span><br><span class="line">    Constructor&lt;?&gt; constructorToUse = <span class="keyword">null</span>;</span><br><span class="line">    ArgumentsHolder argsHolderToUse = <span class="keyword">null</span>;</span><br><span class="line">    Object[] argsToUse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 调用getBean时明确指定了构造参数explicitArgs</span></span><br><span class="line">        argsToUse = explicitArgs;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试从缓存中获取</span></span><br><span class="line">        Object[] argsToResolve = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) mbd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; mbd.constructorArgumentsResolved) &#123;</span><br><span class="line">                <span class="comment">// 找到了缓存的构造方法</span></span><br><span class="line">                argsToUse = mbd.resolvedConstructorArguments;</span><br><span class="line">                <span class="keyword">if</span> (argsToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 配置的构造函数参数</span></span><br><span class="line">                    argsToResolve = mbd.preparedConstructorArguments;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存中存在</span></span><br><span class="line">        <span class="keyword">if</span> (argsToResolve != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 解析参数类型，将字符串值转换为真实的值，缓存中的值可能是原始值也可能是解析后的值</span></span><br><span class="line">            argsToUse = <span class="keyword">this</span>.resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有缓存则从配置文件中解析</span></span><br><span class="line">    <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 需要解析确定具体的构造方法</span></span><br><span class="line">        <span class="keyword">boolean</span> autowiring = (chosenCtors != <span class="keyword">null</span> ||</span><br><span class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);</span><br><span class="line">        ConstructorArgumentValues resolvedValues = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minNrOfArgs; <span class="comment">// 记录解析到的参数个数</span></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            minNrOfArgs = explicitArgs.length;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 提取配置的构造函数参数值</span></span><br><span class="line">            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();</span><br><span class="line">            resolvedValues = <span class="keyword">new</span> ConstructorArgumentValues(); <span class="comment">// 用于承载解析后的构造函数参数的值</span></span><br><span class="line">            <span class="comment">// 解析构造参数</span></span><br><span class="line">            minNrOfArgs = <span class="keyword">this</span>.resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取候选的构造方法集合</span></span><br><span class="line">        Constructor&lt;?&gt;[] candidates = chosenCtors;</span><br><span class="line">        <span class="keyword">if</span> (candidates == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; beanClass = mbd.getBeanClass();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                candidates = (mbd.isNonPublicAccessAllowed() ? beanClass.getDeclaredConstructors() : beanClass.getConstructors());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Resolution of declared constructors on bean Class ["</span> + beanClass.getName() + <span class="string">"] from ClassLoader ["</span> + beanClass.getClassLoader() + <span class="string">"] failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序构造函数，public在前，参数多的在前</span></span><br><span class="line">        AutowireUtils.sortConstructors(candidates);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minTypeDiffWeight = Integer.MAX_VALUE;</span><br><span class="line">        Set&lt;Constructor&lt;?&gt;&gt; ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;UnsatisfiedDependencyException&gt; causes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; candidate : candidates) &#123;</span><br><span class="line">            Class&lt;?&gt;[] paramTypes = candidate.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; argsToUse.length &gt; paramTypes.length) &#123;</span><br><span class="line">                <span class="comment">// 已经找到目标构造函数，或者已有的构造函数的参数个数已经小于期望的个数</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (paramTypes.length &lt; minNrOfArgs) &#123;</span><br><span class="line">                <span class="comment">// 参数个数不相等</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArgumentsHolder argsHolder;</span><br><span class="line">            <span class="keyword">if</span> (resolvedValues != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 有参数则根据对应的值构造对应参数类型的参数</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 从注解上获得参数名称</span></span><br><span class="line">                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);</span><br><span class="line">                    <span class="keyword">if</span> (paramNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取参数名称探测器</span></span><br><span class="line">                        ParameterNameDiscoverer pnd = <span class="keyword">this</span>.beanFactory.getParameterNameDiscoverer();</span><br><span class="line">                        <span class="keyword">if</span> (pnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 获取构造方法的参数名称列表</span></span><br><span class="line">                            paramNames = pnd.getParameterNames(candidate);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 根据数值和类型创建参数持有者</span></span><br><span class="line">                    argsHolder = <span class="keyword">this</span>.createArgumentArray(</span><br><span class="line">                            beanName, mbd, resolvedValues, bw, paramTypes, paramNames, <span class="keyword">this</span>.getUserDeclaredConstructor(candidate), autowiring);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsatisfiedDependencyException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory.logger.isTraceEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.beanFactory.logger.trace(<span class="string">"Ignoring constructor ["</span> + candidate + <span class="string">"] of bean '"</span> + beanName + <span class="string">"': "</span> + ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 尝试下一个构造函数</span></span><br><span class="line">                    <span class="keyword">if</span> (causes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        causes = <span class="keyword">new</span> LinkedList&lt;UnsatisfiedDependencyException&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    causes.add(ex);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 参数个数不匹配</span></span><br><span class="line">                <span class="keyword">if</span> (paramTypes.length != explicitArgs.length) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 构造函数没有参数的情况</span></span><br><span class="line">                argsHolder = <span class="keyword">new</span> ArgumentsHolder(explicitArgs);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 探测是否有不确定性的构造函数存在，不如不同构造函数的参数为继承关系</span></span><br><span class="line">            <span class="keyword">int</span> typeDiffWeight = (mbd.isLenientConstructorResolution() ?</span><br><span class="line">                    argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));</span><br><span class="line">            <span class="comment">// 如果当前的不确定性构造函数最接近期望值，则选择作为构造函数</span></span><br><span class="line">            <span class="keyword">if</span> (typeDiffWeight &lt; minTypeDiffWeight) &#123;</span><br><span class="line">                constructorToUse = candidate;</span><br><span class="line">                argsHolderToUse = argsHolder;</span><br><span class="line">                argsToUse = argsHolder.arguments;</span><br><span class="line">                minTypeDiffWeight = typeDiffWeight;</span><br><span class="line">                ambiguousConstructors = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorToUse != <span class="keyword">null</span> &amp;&amp; typeDiffWeight == minTypeDiffWeight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ambiguousConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ambiguousConstructors = <span class="keyword">new</span> LinkedHashSet&lt;Constructor&lt;?&gt;&gt;();</span><br><span class="line">                    ambiguousConstructors.add(constructorToUse);</span><br><span class="line">                &#125;</span><br><span class="line">                ambiguousConstructors.add(candidate);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (causes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                UnsatisfiedDependencyException ex = causes.removeLast();</span><br><span class="line">                <span class="keyword">for</span> (Exception cause : causes) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.beanFactory.onSuppressedException(cause);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ambiguousConstructors != <span class="keyword">null</span> &amp;&amp; !mbd.isLenientConstructorResolution()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Ambiguous constructor matches found in bean '"</span> + beanName + <span class="string">"' (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): "</span> + ambiguousConstructors);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (explicitArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将解析的构造函数加入缓存</span></span><br><span class="line">            argsHolderToUse.storeCache(mbd, constructorToUse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依据构造方法进行实例化</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; ctorToUse = constructorToUse;</span><br><span class="line">            <span class="keyword">final</span> Object[] argumentsToUse = argsToUse;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                            mbd, beanName, beanFactory, ctorToUse, argumentsToUse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, beanFactory.getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 基于反射创建对象</span></span><br><span class="line">            beanInstance = <span class="keyword">this</span>.beanFactory.getInstantiationStrategy().instantiate(</span><br><span class="line">                    mbd, beanName, <span class="keyword">this</span>.beanFactory, constructorToUse, argsToUse);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将构造的实例加入BeanWrapper</span></span><br><span class="line">        bw.setBeanInstance(beanInstance);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Bean instantiation via constructor failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个方法的设计思想与前面通过工厂方法实例化对象相同，具体可参考注释，不再展开，而如果没有指定或配置构造参数，容器会采用默认的构造方法创建对象，该过程位于 instantiateBean 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 利用反射进行实例化</span></span><br><span class="line">            beanInstance = <span class="keyword">this</span>.getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用包装器包装bean实例</span></span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        <span class="keyword">this</span>.initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要知晓的一点是，经过上面的流程，不管是通过通过工厂方法还是构造方法来实例化对象，到这里得到的也仅仅是一个 bean 的最初实例，还不是我们最终期望的 bean，因为后面还需要对 bean 实例进行初始化处理，注入相应的属性值等。</p>
<p><strong>3. 应用 MergedBeanDefinitionPostProcessor</strong></p>
<p>如果我们实现并注册了 MergedBeanDefinitionPostProcessor 处理器，希望在对 bean 初始化之前对 beanDefinition 进行处理，那么这些处理器会在这里被逐一调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有的后置处理器</span></span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            <span class="comment">// 如果是 MergedBeanDefinitionPostProcessor 则进行应用</span></span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. 检查是否需要提前曝光，避免循环依赖</strong></p>
<p>对于单例而言，Spring 会通过提前曝光的机制来尝试解决循环依赖导致的死锁问题，循环依赖导致的死锁除了发生在构造方法注入时，也可能发生在 setter 方法注入过程中，对于前者而言，容器是无法解决循环依赖问题的，只能抛出异常，而后者则可以通过提前曝光的机制来达到“先引用，后初始化”的目的，所以不会死锁，这个过程的关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (</span><br><span class="line">            mbd.isSingleton() <span class="comment">// 单例</span></span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">// 允许循环依赖，需要通过程序设置</span></span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.isSingletonCurrentlyInCreation(beanName)); <span class="comment">// 当前 bean 正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 为避免循环依赖，在完成bean实例化之前，将对应的ObjectFactory加入创建bean的工厂集合中</span></span><br><span class="line">        <span class="keyword">this</span>.addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="comment">// 对bean再一次依赖引用，应用SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>方法的逻辑是先判断是否允许提前曝光，如果当前为单例 bean，且程序制定允许循环引用，同时当前 bean 正处于创建中，则会将创建 bean 的 ObjectFactory 对象加入到用于保存 beanName 和创建 bean 的工厂之间的关系的集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明一下方法中各个变量的意义</p>
<ul>
<li>singletonObjects：用于保存 beanName 和 bean 实例之间的关系</li>
<li>singletonFactories：用于保存 beanName 和 创建 bean 的工厂之间的关系</li>
<li>earlySingletonObjects：也是保存 beanName 和 bean 实例之间的关系，不同于 singletonObjects，当一个bean的实例放置于其中后，当bean还在创建过程中就可以通过 getBean 方法获取到</li>
<li>registeredSingletons：用来保存当前所有已注册的 bean</li>
</ul>
</blockquote>
<p>上面这段逻辑位于初始化 bean 实例之前，其用意就是当初始化一个 bean 时，如果引用了另外一个 bean，这个时候就需要转而去创建并初始化另外一个 bean，如果恰好该 bean 引用了之前的 bean 就出现了循环依赖，假设我们令第一个 bean 为 A，第二个 bean 为 B，基于这段代码的逻辑，B 就可以先给自己类型为 A 的属性注入 A 的实例（这个时候 A 还没有被初始化），然后完成初始化，此时继续回到初始化 A 的逻辑，因为都是单例，所以当 A 完成了初始化之后，B 所引用的 A 对象也就是一个完成了初始化过程的对象，而不是之前的刚刚完成对象创建还没有注入属性的实例。</p>
<p><strong>5. 初始化 bean 实例</strong></p>
<p>整个初始化过程包括 <strong>属性注入</strong> 和 <strong>执行初始化方法</strong> 两个步骤。我们先来看属性注入的过程，该过程位于 populateBean 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取bean实例的属性值集合</span></span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// null对象，但是存在填充的属性，不合理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// null 对象，且没有属性可以填充，直接返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 给InstantiationAwareBeanPostProcessors最后一次机会在注入属性前改变bean实例</span></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="comment">// 是否继续填充bean</span></span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果处理器指明不需要再继续执行属性注入，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// autowire by name or autowire by type</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME</span><br><span class="line">            || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">        <span class="comment">// 根据名称自动注入</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            <span class="keyword">this</span>.autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据类型自动注入</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            <span class="keyword">this</span>.autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = <span class="keyword">this</span>.hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="comment">// 在属性注入前应用实例化后置处理器</span></span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : <span class="keyword">this</span>.getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    <span class="comment">// 调用后置处理器的postProcessPropertyValues方法</span></span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 处理器中把属性值处理没了，则继续执行属性注入已经没有意义</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依赖检查，对应depends-on属性，该属性已经弃用</span></span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            <span class="keyword">this</span>.checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行属性注入</span></span><br><span class="line">    <span class="keyword">this</span>.applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中会执行 InstantiationAwareBeanPostProcessor 后置处理器的 postProcessAfterInstantiation 方法逻辑，从而实现对完成实例化且还没有注入属性值的对象进行最后的更改，如果我们在 postProcessAfterInstantiation 指明不需要执行后续的属性注入过程，则方法到此结束。否则方法会检测当前的注入类型，是 byName 还是 byType，并调用相应的注入逻辑获取依赖的 bean，加入属性集合中。然后方法会调用 InstantiationAwareBeanPostProcessor 后置处理器的 postProcessPropertyValues 方法，实现在将属性值应用到 bean 实例之前的最后一次对属性值的更改，同时会依据配置执行依赖检查，以确保所有的属性都被赋值（这里的赋值是指 beanDefinition 中的属性都有对应的值，而不是指最终 bean 实例的属性是否注入了对应的值）。最后将输入值应用到 bean 实例对应的属性上。</p>
<ul>
<li><strong>autowireByName</strong></li>
</ul>
<p>如果当前注入类型是 byName，则容器会基于 beanName 获取依赖的 bean，并将依赖关系保存在对应的集合中，如果依赖的 bean 未被实例化则需要执行实例化逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找需要注入的属性</span></span><br><span class="line">    String[] propertyNames = <span class="keyword">this</span>.unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.containsBean(propertyName)) &#123;</span><br><span class="line">            <span class="comment">// 如果依赖的bean没有初始化，则递归初始化相关的bean</span></span><br><span class="line">            Object bean = <span class="keyword">this</span>.getBean(propertyName);</span><br><span class="line">            <span class="comment">// 添加到属性集合中</span></span><br><span class="line">            pvs.add(propertyName, bean);</span><br><span class="line">            <span class="comment">// 记录依赖关系到集合中</span></span><br><span class="line">            <span class="keyword">this</span>.registerDependentBean(propertyName, beanName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>autowireByType</strong></li>
</ul>
<p>如果当前注入类型是 byType，则容器会依据类型去确定对应的 bean，并将依赖关系保存到对应的集合中，如果依赖的 bean 未被实例化则需要执行实例化逻辑，因为类型注入需要一个推断的过程，所以实现逻辑要复杂很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">autowireByType</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TypeConverter converter = <span class="keyword">this</span>.getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;String&gt; autowiredBeanNames = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 寻找需要注入的属性</span></span><br><span class="line">    String[] propertyNames = <span class="keyword">this</span>.unsatisfiedNonSimpleProperties(mbd, bw);</span><br><span class="line">    <span class="keyword">for</span> (String propertyName : propertyNames) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);</span><br><span class="line">            <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span> !</span>= pd.getPropertyType()) &#123;</span><br><span class="line">                <span class="comment">// 获取指定属性的set方法</span></span><br><span class="line">                MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);</span><br><span class="line">                <span class="keyword">boolean</span> eager = !PriorityOrdered<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">bw</span>.<span class="title">getWrappedClass</span>())</span>;</span><br><span class="line">                DependencyDescriptor desc = <span class="keyword">new</span> AutowireByTypeDependencyDescriptor(methodParam, eager);</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 解析指定beanName的属性所匹配的值，并把解析到的属性存储在autowiredBeanNames中，当属性存在多个封装的bean时，比如：</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * @Autowired</span></span><br><span class="line"><span class="comment">                 * private List&lt;A&gt; list</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 将会找到所有匹配A类型的bean，并将其注入</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                Object autowiredArgument = <span class="keyword">this</span>.resolveDependency(desc, beanName, autowiredBeanNames, converter);</span><br><span class="line">                <span class="keyword">if</span> (autowiredArgument != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pvs.add(propertyName, autowiredArgument);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;</span><br><span class="line">                    <span class="comment">// 记录bean之间的依赖关系</span></span><br><span class="line">                    <span class="keyword">this</span>.registerDependentBean(autowiredBeanName, beanName);</span><br><span class="line">                    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                        logger.debug(<span class="string">"Autowiring by type from bean name '"</span> + beanName + <span class="string">"' via property '"</span> + propertyName + <span class="string">"' to bean named '"</span> + autowiredBeanName + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                autowiredBeanNames.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法的核心位于 resolveDependency 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveDependency</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        DependencyDescriptor descriptor, String requestingBeanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取并初始化参数名称探测器</span></span><br><span class="line">    descriptor.initParameterNameDiscovery(<span class="keyword">this</span>.getParameterNameDiscoverer());</span><br><span class="line">    <span class="keyword">if</span> (javaUtilOptionalClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 支持java8的java.util.Optional</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OptionalDependencyFactory().createOptionalDependency(descriptor, requestingBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ObjectFactory<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType() || ObjectProvider<span class="class">.<span class="keyword">class</span> </span>== descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// ObjectFactory类注入的特殊处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DependencyObjectProvider(descriptor, requestingBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (javaxInjectProviderClass == descriptor.getDependencyType()) &#123;</span><br><span class="line">        <span class="comment">// 支持javax.inject.Provider</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object result = <span class="keyword">this</span>.getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(descriptor, requestingBeanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 通用处理逻辑</span></span><br><span class="line">            result = <span class="keyword">this</span>.doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doResolveDependency</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        DependencyDescriptor descriptor, String beanName, Set&lt;String&gt; autowiredBeanNames, TypeConverter typeConverter)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 快速处理</span></span><br><span class="line">        Object shortcut = descriptor.resolveShortcut(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (shortcut != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> shortcut;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是@Value注解，获取并返回对应的值</span></span><br><span class="line">        Class&lt;?&gt; type = descriptor.getDependencyType();</span><br><span class="line">        Object value = <span class="keyword">this</span>.getAutowireCandidateResolver().getSuggestedValue(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = <span class="keyword">this</span>.resolveEmbeddedValue((String) value);</span><br><span class="line">                BeanDefinition bd = (beanName != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.containsBean(beanName) ? <span class="keyword">this</span>.getMergedBeanDefinition(beanName) : <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 如果value是一个表达式，则解析表达式所指代的值</span></span><br><span class="line">                value = <span class="keyword">this</span>.evaluateBeanDefinitionString(strVal, bd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 类型转换并返回</span></span><br><span class="line">            TypeConverter converter = (typeConverter != <span class="keyword">null</span> ? typeConverter : <span class="keyword">this</span>.getTypeConverter());</span><br><span class="line">            <span class="keyword">return</span> (descriptor.getField() != <span class="keyword">null</span> ?</span><br><span class="line">                    converter.convertIfNecessary(value, type, descriptor.getField()) :</span><br><span class="line">                    converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试解析数组、集合类型</span></span><br><span class="line">        Object multipleBeans = <span class="keyword">this</span>.resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);</span><br><span class="line">        <span class="keyword">if</span> (multipleBeans != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> multipleBeans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取匹配类型的bean实例</span></span><br><span class="line">        Map&lt;String, Object&gt; matchingBeans = <span class="keyword">this</span>.findAutowireCandidates(beanName, type, descriptor);</span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (descriptor.isRequired()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String autowiredBeanName;</span><br><span class="line">        Object instanceCandidate;</span><br><span class="line">        <span class="comment">// 存在多个匹配项</span></span><br><span class="line">        <span class="keyword">if</span> (matchingBeans.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 基于优先级配置来唯一确定注入的bean</span></span><br><span class="line">            autowiredBeanName = <span class="keyword">this</span>.determineAutowireCandidate(matchingBeans, descriptor);</span><br><span class="line">            <span class="keyword">if</span> (autowiredBeanName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (descriptor.isRequired() || !<span class="keyword">this</span>.indicatesMultipleBeans(type)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> descriptor.resolveNotUnique(type, matchingBeans);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            instanceCandidate = matchingBeans.get(autowiredBeanName);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存在唯一的匹配</span></span><br><span class="line">            Map.Entry&lt;String, Object&gt; entry = matchingBeans.entrySet().iterator().next();</span><br><span class="line">            autowiredBeanName = entry.getKey();</span><br><span class="line">            instanceCandidate = entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (autowiredBeanNames != <span class="keyword">null</span>) &#123;</span><br><span class="line">            autowiredBeanNames.add(autowiredBeanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是目标bean实例（比如工厂bean），需要进一步获取所指带的实例</span></span><br><span class="line">        <span class="keyword">return</span> (instanceCandidate <span class="keyword">instanceof</span> Class ?</span><br><span class="line">                descriptor.resolveCandidate(autowiredBeanName, type, <span class="keyword">this</span>) : instanceCandidate);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个解析的过程还是比较清晰的，首先会依次以确定的 <code>@Value</code> 注解和集合类型进行解析，如果不是这些类型，则获取匹配类型的 bean 实例集合，如果存在多个匹配，则尝试以优先级配置（比如 Primary 或 Priority）来确定首选的 bean 实例，如果仅存在唯一的匹配，则无需做推断逻辑，最后会检测当前解析得到的 bean 是不是目标 bean 实例，如果是工厂一类的 bean，则还要继续获取工厂所指代的 bean 实例。</p>
<ul>
<li><strong>applyPropertyValues</strong></li>
</ul>
<p>在这一步才真正将 bean 的所有属性全部注入到 bean 实例中，之前虽然已经创建了实例，但是属性仍然存在于 beanDefinition 实例中，applyPropertyValues 会将相应属性转换成 bean 中对应属性的真实类型注入到对应属性上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValues</span><span class="params">(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pvs == <span class="keyword">null</span> || pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MutablePropertyValues mpvs = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;PropertyValue&gt; original;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bw <span class="keyword">instanceof</span> BeanWrapperImpl) &#123;</span><br><span class="line">            ((BeanWrapperImpl) bw).setSecurityContext(<span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pvs <span class="keyword">instanceof</span> MutablePropertyValues) &#123;</span><br><span class="line">        mpvs = (MutablePropertyValues) pvs;</span><br><span class="line">        <span class="keyword">if</span> (mpvs.isConverted()) &#123;</span><br><span class="line">            <span class="comment">// 之前已经被转换为对应的类型，那么可以直接设置到beanWrapper</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.setPropertyValues(mpvs);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未被转换，记录到original进行转换</span></span><br><span class="line">        original = mpvs.getPropertyValueList();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，使用原始的属性获取方法</span></span><br><span class="line">        original = Arrays.asList(pvs.getPropertyValues());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TypeConverter converter = <span class="keyword">this</span>.getCustomTypeConverter();</span><br><span class="line">    <span class="keyword">if</span> (converter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        converter = bw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取对应的解析器</span></span><br><span class="line">    BeanDefinitionValueResolver valueResolver = <span class="keyword">new</span> BeanDefinitionValueResolver(<span class="keyword">this</span>, beanName, mbd, converter);</span><br><span class="line"></span><br><span class="line">    List&lt;PropertyValue&gt; deepCopy = <span class="keyword">new</span> ArrayList&lt;PropertyValue&gt;(original.size());</span><br><span class="line">    <span class="keyword">boolean</span> resolveNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 遍历属性，将属性转换成对应类的属性类型</span></span><br><span class="line">    <span class="keyword">for</span> (PropertyValue pv : original) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pv.isConverted()) &#123;</span><br><span class="line">            deepCopy.add(pv);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 执行类型转换</span></span><br><span class="line">            String propertyName = pv.getName();</span><br><span class="line">            Object originalValue = pv.getValue();</span><br><span class="line">            Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);</span><br><span class="line">            Object convertedValue = resolvedValue;</span><br><span class="line">            <span class="keyword">boolean</span> convertible = bw.isWritableProperty(propertyName) &amp;&amp; !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);</span><br><span class="line">            <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                <span class="comment">// 转换</span></span><br><span class="line">                convertedValue = <span class="keyword">this</span>.convertForProperty(resolvedValue, propertyName, bw, converter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (resolvedValue == originalValue) &#123;</span><br><span class="line">                <span class="comment">// 转换后的value等于原始值</span></span><br><span class="line">                <span class="keyword">if</span> (convertible) &#123;</span><br><span class="line">                    pv.setConvertedValue(convertedValue);</span><br><span class="line">                &#125;</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (convertible &amp;&amp; originalValue <span class="keyword">instanceof</span> TypedStringValue &amp;&amp;</span><br><span class="line">                    !((TypedStringValue) originalValue).isDynamic() &amp;&amp;</span><br><span class="line">                    !(convertedValue <span class="keyword">instanceof</span> Collection || ObjectUtils.isArray(convertedValue))) &#123;</span><br><span class="line">                <span class="comment">// 转换后的类型是集合或数组</span></span><br><span class="line">                pv.setConvertedValue(convertedValue);</span><br><span class="line">                deepCopy.add(pv);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 未解析完全，标记需要解析</span></span><br><span class="line">                resolveNecessary = <span class="keyword">true</span>;</span><br><span class="line">                deepCopy.add(<span class="keyword">new</span> PropertyValue(pv, convertedValue));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mpvs != <span class="keyword">null</span> &amp;&amp; !resolveNecessary) &#123;</span><br><span class="line">        mpvs.setConverted(); <span class="comment">// 标记为已全部转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 深拷贝</span></span><br><span class="line">        bw.setPropertyValues(<span class="keyword">new</span> MutablePropertyValues(deepCopy));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName, <span class="string">"Error setting property values"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成了属性注入，接下来容器会执行我们所熟知的 init-method 方法，不过 Spring 并不是单纯的调用一下对应的初始化方法，在整一个初始化方法 initializeBean 中，容器主要做了 4 件事情：</p>
<blockquote>
<ol>
<li>激活 bean 实现的 Aware 类：BeanNameAware, BeanClassLoaderAware, BeanFactoryAware</li>
<li>应用 BeanPostProcessor 的 postProcessBeforeInitialization</li>
<li>激活用户自定义的 init-method 方法，以及常用的 afterPropertiesSet 方法</li>
<li>应用 BeanPostProcessor 的 postProcessAfterInitialization</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 激活bean实现的Aware类：BeanNameAware, BeanClassLoaderAware, BeanFactoryAware</span></span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 应用 BeanPostProcessor 的 postProcessBeforeInitialization</span></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 激活用户自定义的 init-method 方法，以及常用的 afterPropertiesSet 方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException((mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>), beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 应用 BeanPostProcessor 的 postProcessAfterInitialization</span></span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = <span class="keyword">this</span>.applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. 基于依存关系验证是否存在循环依赖</strong></p>
<p>存在循环依赖会导致容器中存在残缺的 bean，这对于使用 Spring 框架的系统来说是一个极大的隐患，所以在这里最后再检测一次，确保所有需要实例化的 bean 都完成了对象的创建和初始化过程，否则系统不应该正常启动。</p>
<p><strong>7. 注册 DisposableBean</strong></p>
<p>Spring 允许单例或自定义作用域的 bean 实现 DisposableBean 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked by a BeanFactory on destruction of a singleton.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception in case of shutdown errors.</span></span><br><span class="line"><span class="comment">     *                   Exceptions will get logged but not rethrown to allow</span></span><br><span class="line"><span class="comment">     *                   other beans to release their resources too.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从而在销毁对应的 bean 时能够回调实现的 destroy 方法，从而为销毁前的处理工作提供了入口，容器会利用一个 Map 集合来记录所有实现了 DisposableBean 接口的 bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerDisposableBeanIfNecessary</span><span class="params">(String beanName, Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    AccessControlContext acc = (System.getSecurityManager() != <span class="keyword">null</span> ? getAccessControlContext() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isPrototype() &amp;&amp; <span class="keyword">this</span>.requiresDestruction(bean, mbd)) &#123;</span><br><span class="line">        <span class="comment">// 非原型，且需要执行销毁前的处理工作</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            <span class="comment">// 单例，注册bean到disposableBeans集合</span></span><br><span class="line">            <span class="keyword">this</span>.registerDisposableBean(beanName, <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, <span class="keyword">this</span>.getBeanPostProcessors(), acc));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 自定义的scope</span></span><br><span class="line">            Scope scope = <span class="keyword">this</span>.scopes.get(mbd.getScope());</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + mbd.getScope() + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            scope.registerDestructionCallback(beanName, <span class="keyword">new</span> DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们在调用 destroySingleton 销毁 bean 的时候，容器就会尝试从 DisposableBean 集合中获取当前待销毁 bean 对应的 DisposableBean 实例，如果存在则调用 destroy 方法，执行其中的自定义逻辑。</p>
<h3 id="创建原型对象"><a href="#创建原型对象" class="headerlink" title="创建原型对象"></a>创建原型对象</h3><p>创建和初始化过程调用的 createBean 方法同单例对象，不再重复撰述。</p>
<h3 id="创建其它作用域对象"><a href="#创建其它作用域对象" class="headerlink" title="创建其它作用域对象"></a>创建其它作用域对象</h3><p>创建和初始化过程调用的 createBean 方法同单例对象，不再重复撰述。</p>
<h2 id="类型检查和转换"><a href="#类型检查和转换" class="headerlink" title="类型检查和转换"></a>类型检查和转换</h2><p>我们在 getBean 的时候可以指定我们期望的返回类型 <code>getBean(String name, Class requiredType)</code>，如果我们指定了那么容器在创建和初始化 bean 的最后一步需要执行类型校验，并尝试将不是期望类型的 bean 实例转换成期望类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查需要的类型是否符合bean的实际类型，对应getBean时指定的requireType</span></span><br><span class="line"><span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isAssignableFrom(bean.getClass())) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行类型转换，转换成期望的类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> + ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个转换的过程还是比较复杂的，鉴于本篇已经写的够长了，就不再展开啦。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><p><a href="https://my.oschina.net/wangzhenchao/blog/918237" target="_blank" rel="noopener">https://my.oschina.net/wangzhenchao/blog/918237</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/spring/" rel="tag"># spring</a>
              <a href="/tags/springframe/" rel="tag"># springframe</a>
              <a href="/tags/bean/" rel="tag"># bean</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/16/spring/spring-core/spring-0-%E9%87%8D%E8%A6%81%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89/" rel="prev" title="spring-0-重要接口定义">
      <i class="fa fa-chevron-left"></i> spring-0-重要接口定义
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/16/spring/spring-core/spring-4-%E5%BA%94%E7%94%A8%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84refresh/" rel="next" title="spring-4-应用上下文的refresh方法(转)">
      spring-4-应用上下文的refresh方法(转) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取真正的-beanName"><span class="nav-number">2.</span> <span class="nav-text">获取真正的 beanName</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#尝试从单例集合中获取目标-bean"><span class="nav-number">3.</span> <span class="nav-text">尝试从单例集合中获取目标 bean</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从-bean-实例中获取目标对象"><span class="nav-number">4.</span> <span class="nav-text">从 bean 实例中获取目标对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-bean-实例"><span class="nav-number">5.</span> <span class="nav-text">创建 bean 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建单例对象"><span class="nav-number">5.1.</span> <span class="nav-text">创建单例对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取-class-引用"><span class="nav-number">5.1.1.</span> <span class="nav-text">获取 class 引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-override-属性"><span class="nav-number">5.1.2.</span> <span class="nav-text">处理 override 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理-InstantiationAwareBeanPostProcessor"><span class="nav-number">5.1.3.</span> <span class="nav-text">处理 InstantiationAwareBeanPostProcessor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例化-bean"><span class="nav-number">5.1.4.</span> <span class="nav-text">实例化 bean</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建原型对象"><span class="nav-number">5.2.</span> <span class="nav-text">创建原型对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建其它作用域对象"><span class="nav-number">5.3.</span> <span class="nav-text">创建其它作用域对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类型检查和转换"><span class="nav-number">6.</span> <span class="nav-text">类型检查和转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#来源"><span class="nav-number">7.</span> <span class="nav-text">来源</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhoul</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">351</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">92</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">190</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/longzl2015" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;longzl2015" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:289570126@qq.com" title="E-Mail → mailto:289570126@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/5276366/egg" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;5276366&#x2F;egg" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhoul</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://long12356-gitee-io.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: {page: {
            url: "https://longzl2015.github.io/2019/10/16/spring/spring-core/spring-1-bean%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/",
            identifier: "2019/10/16/spring/spring-core/spring-1-bean的创建和初始化/",
            title: "spring-3-bean的创建和初始化(转)"
          }
        }
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://long12356-gitee-io.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>

</body>
</html>
